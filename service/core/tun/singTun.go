package tun

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net"
	"net/netip"
	"os"
	"slices"
	"sync"
	"time"

	tun "github.com/sagernet/sing-tun"
	"github.com/sagernet/sing/common/bufio"
	"github.com/sagernet/sing/common/control"
	"github.com/sagernet/sing/common/logger"
	M "github.com/sagernet/sing/common/metadata"
	N "github.com/sagernet/sing/common/network"
	"github.com/sagernet/sing/protocol/socks"
	"github.com/v2fly/v2ray-core/v5/common/strmatcher"
	"github.com/v2rayA/v2ray-lib/router/routercommon"
	"github.com/v2rayA/v2rayA/core/v2ray/asset"
	"github.com/v2rayA/v2rayA/pkg/util/log"
	"google.golang.org/protobuf/proto"
)

const (
	// DNS addresses should point to the TUN interface itself, not gateway
	// sing-tun intercepts DNS traffic to port 53 and handles it internally
	dnsAddr  = "172.19.0.2"
	dnsAddr6 = "fdfe:dcba:9876::2"
)

var (
	prefix4 = netip.MustParsePrefix("172.19.0.1/30")
	prefix6 = netip.MustParsePrefix("fdfe:dcba:9876::1/126")
	route4  = netip.MustParsePrefix("0.0.0.0/0")
	route6  = netip.MustParsePrefix("::/0")

	defaultLogger = logger.NOP()

	continueHandler = errors.New("continue handler")
)

type singTun struct {
	mu               sync.Mutex
	dialer           N.Dialer
	forward          N.Dialer
	cancel           context.CancelFunc
	closer           io.Closer
	waiter           *gvisorWaiter
	dns              *DNS
	whitelist        []netip.Addr
	excludeAddrs     []netip.Prefix // Addresses to exclude from TUN routing
	useIPv6          bool
	strictRoute      bool
	autoRoute        bool
	runningAutoRoute bool   // effective autoRoute after platform override
	tunName          string // TUN interface name for cleanup
}

// isReservedAddress checks if an IP address belongs to reserved address ranges
// that should not be proxied (loopback, private, link-local, multicast, etc.)
func isReservedAddress(addr netip.Addr) bool {
	if !addr.IsValid() {
		return false
	}

	// IPv4 reserved ranges
	if addr.Is4() {
		// 127.0.0.0/8 - Loopback
		if addr.AsSlice()[0] == 127 {
			return true
		}
		// 10.0.0.0/8 - Private network Class A
		if addr.AsSlice()[0] == 10 {
			return true
		}
		// 172.16.0.0/12 - Private network Class B
		if addr.AsSlice()[0] == 172 && (addr.AsSlice()[1]&0xF0) == 16 {
			return true
		}
		// 192.168.0.0/16 - Private network Class C
		if addr.AsSlice()[0] == 192 && addr.AsSlice()[1] == 168 {
			return true
		}
		// 169.254.0.0/16 - Link-local
		if addr.AsSlice()[0] == 169 && addr.AsSlice()[1] == 254 {
			return true
		}
		// 224.0.0.0/4 - Multicast
		if (addr.AsSlice()[0] & 0xF0) == 224 {
			return true
		}
		// 240.0.0.0/4 - Reserved
		if (addr.AsSlice()[0] & 0xF0) == 240 {
			return true
		}
		// 0.0.0.0/8 - Current network
		if addr.AsSlice()[0] == 0 {
			return true
		}
	}

	// IPv6 reserved ranges
	if addr.Is6() {
		// ::1/128 - Loopback
		if addr.IsLoopback() {
			return true
		}
		// fe80::/10 - Link-local unicast
		if addr.IsLinkLocalUnicast() {
			return true
		}
		// fc00::/7 - Unique local address (ULA)
		if (addr.AsSlice()[0] & 0xFE) == 0xFC {
			return true
		}
		// ff00::/8 - Multicast
		if addr.IsMulticast() {
			return true
		}
		// ::/128 - Unspecified address
		if addr.IsUnspecified() {
			return true
		}
	}

	return false
}

func filterTunDNSServers(servers []netip.AddrPort) []netip.AddrPort {
	dnsAddrIP, _ := netip.ParseAddr(dnsAddr)
	dnsAddrIPv6, _ := netip.ParseAddr(dnsAddr6)
	filtered := make([]netip.AddrPort, 0, len(servers))
	for _, server := range servers {
		addr := server.Addr()
		if !addr.IsValid() {
			continue
		}
		if addr.IsLoopback() || addr.IsUnspecified() {
			continue
		}
		if dnsAddrIP.IsValid() && addr == dnsAddrIP {
			continue
		}
		if dnsAddrIPv6.IsValid() && addr == dnsAddrIPv6 {
			continue
		}
		filtered = append(filtered, server)
	}
	if len(filtered) == 0 {
		return nil
	}
	return filtered
}

// resolveDnsHost resolves a hostname to both A and AAAA records.
// Returns normalised IP addresses (IPv4-in-IPv6 addresses are unmapped to
// pure IPv4 so they match the canonical form sing-tun uses).
func resolveDnsHost(host string) []netip.Addr {
	var ips []netip.Addr

	// Already an IP address – just normalise and return.
	if addr, err := netip.ParseAddr(host); err == nil {
		return []netip.Addr{addr.Unmap()}
	}

	// Resolve A + AAAA records.
	if addrs, err := net.LookupIP(host); err == nil {
		for _, addr := range addrs {
			if ipAddr, ok := netip.AddrFromSlice(addr); ok {
				// net.LookupIP may return IPv4 as 16-byte IPv4-in-IPv6.
				// Unmap to canonical Is4() so whitelist lookups match.
				ips = append(ips, ipAddr.Unmap())
			}
		}
	} else {
		log.Warn("[TUN] Failed to resolve DNS host %s: %v", host, err)
	}

	return ips
}

// ResolveDnsServersToExcludes resolves DNS server hostnames to IP prefixes for TUN exclusion
// This prevents DNS server traffic from being intercepted by TUN, avoiding routing loops
func ResolveDnsServersToExcludes(dnsHosts []string) []netip.Prefix {
	var excludes []netip.Prefix
	seen := make(map[netip.Addr]bool)

	log.Info("[TUN] Resolving DNS servers for exclusion: %v", dnsHosts)

	for _, host := range dnsHosts {
		ips := resolveDnsHost(host)
		for _, ip := range ips {
			if seen[ip] {
				continue
			}
			seen[ip] = true

			// Convert IP to /32 (IPv4) or /128 (IPv6) prefix
			var prefix netip.Prefix
			if ip.Is4() {
				prefix = netip.PrefixFrom(ip, 32)
			} else {
				prefix = netip.PrefixFrom(ip, 128)
			}
			excludes = append(excludes, prefix)
			log.Info("[TUN] Added DNS server %s (%s) to exclusion list", host, ip)
		}
	}

	return excludes
}

func NewSingTun() Tun {
	dialer := N.SystemDialer
	client := socks.NewClient(dialer, M.ParseSocksaddrHostPort("127.0.0.1", 52345), socks.Version5, "", "")
	log.Info("[TUN] Initialized SOCKS5 client to 127.0.0.1:52345")
	return &singTun{
		dialer:      dialer,
		forward:     client,
		strictRoute: false,
		autoRoute:   true, // Default to enabled
		// DNS: dialer is for forwarding to dokodemo-door (127.0.0.1:6053)
		// forward is nil, so all DNS queries will use dnsForward mode
		// No DNS server addresses - TUN only forwards to port 6053
		dns: NewDNS(dialer, nil, false),
	}
}

func (t *singTun) Start(stack Stack) error {
	var failedCloser Closer
	defer func() {
		failedCloser.Close()
	}()

	// ── 保存调用方在 Start() 前设置的排除/白名单配置 ─────────────────────────
	// Close() 会清空 t.excludeAddrs / t.whitelist / t.dns.whitelist，
	// 必须先快照，待 Close() 之后恢复，新的 TUN 实例才能使用这些配置。
	savedExclude := make([]netip.Prefix, len(t.excludeAddrs))
	copy(savedExclude, t.excludeAddrs)
	savedWhitelist := make([]netip.Addr, len(t.whitelist))
	copy(savedWhitelist, t.whitelist)
	savedDomainWhitelist := make(Matcher, len(t.dns.whitelist))
	copy(savedDomainWhitelist, t.dns.whitelist)

	// 根据平台预排除需要绕过 TUN 的地址（如 Windows 上的公共 DNS）
	for _, prefix := range platformPreExcludeAddrs() {
		exists := false
		for _, ex := range savedExclude {
			if ex == prefix {
				exists = true
				break
			}
		}
		if !exists {
			savedExclude = append(savedExclude, prefix)
			log.Info("[TUN] 平台预排除地址: %s", prefix)
		}
	}

	// 关闭旧实例（会清空字段），然后立即恢复配置。
	t.Close()
	t.excludeAddrs = savedExclude
	t.whitelist = savedWhitelist
	t.dns.whitelist = savedDomainWhitelist
	networkUpdateMonitor, err := tun.NewNetworkUpdateMonitor(defaultLogger)
	if err != nil {
		return err
	}
	failedCloser = append(failedCloser, networkUpdateMonitor)
	interfaceMonitor, err := tun.NewDefaultInterfaceMonitor(networkUpdateMonitor, defaultLogger, tun.DefaultInterfaceMonitorOptions{})
	if err != nil {
		return err
	}
	failedCloser = append(failedCloser, interfaceMonitor)
	// Separate excluded addresses by IP version for TUN options
	var inet4Exclude, inet6Exclude []netip.Prefix

	// Always exclude 127.0.0.0/8 (loopback) to prevent capturing local proxy traffic
	loopback4 := netip.MustParsePrefix("127.0.0.0/8")
	inet4Exclude = append(inet4Exclude, loopback4)
	log.Info("[TUN] Excluding loopback: 127.0.0.0/8")

	for _, prefix := range t.excludeAddrs {
		if prefix.Addr().Is4() {
			inet4Exclude = append(inet4Exclude, prefix)
			log.Info("[TUN] Excluding IPv4: %s", prefix.String())
		} else {
			inet6Exclude = append(inet6Exclude, prefix)
			log.Info("[TUN] Excluding IPv6: %s", prefix.String())
		}
	}

	autoRoute := t.autoRoute
	strictRoute := t.strictRoute

	// 某些平台（如 Windows）需要关闭 sing-tun 的 AutoRoute，改用手动路由
	if platformDisableAutoRoute() && autoRoute {
		autoRoute = false
		log.Info("[TUN] 平台要求关闭 AutoRoute，改由手动路由管理")
	} else if !t.autoRoute {
		log.Info("[TUN] AutoRoute 已由用户配置禁用")
	}

	// 记录生效的 autoRoute，供 Close() 中的平台清理逻辑使用
	t.runningAutoRoute = autoRoute

	log.Info("[TUN] Starting with StrictRoute=%t, AutoRoute=%t", strictRoute, autoRoute)
	log.Info("[TUN] Total exclusions: %d IPv4, %d IPv6", len(inet4Exclude), len(inet6Exclude))
	if platformDisableAutoRoute() && strictRoute {
		log.Warn("[TUN] 当前平台：StrictRoute 可能只允许主进程流量通过！")
	}

	// When AutoRoute is enabled, let sing-tun handle exclusion via InetRouteExcludeAddress.
	// Only install OS-level routes on platforms that disable AutoRoute (e.g. Windows)
	// or when the user explicitly turns AutoRoute off.
	if !autoRoute && len(t.excludeAddrs) > 0 {
		if err := SetupExcludeRoutes(t.excludeAddrs); err != nil {
			log.Warn("[TUN] Failed to pre-install exclude routes: %v", err)
		}
	} else if autoRoute {
		log.Info("[TUN] AutoRoute enabled; rely on sing-tun exclude list for %d entries", len(t.excludeAddrs))
	}

	// 接口名由平台函数决定（macOS 需返回空字符串以自动分配 utun*）
	tunName := platformTunName()
	if tunName == "" {
		log.Info("[TUN] 使用系统自动分配的接口名")
	} else {
		log.Info("[TUN] 使用接口名: %s", tunName)
	}

	tunOptions := tun.Options{
		Name:                     tun.CalculateInterfaceName(tunName),
		MTU:                      9000,
		Inet4Address:             []netip.Prefix{prefix4},
		Inet4RouteAddress:        []netip.Prefix{route4},
		Inet4RouteExcludeAddress: inet4Exclude, // Exclude loopback + server IPs
		AutoRoute:                autoRoute,
		StrictRoute:              strictRoute,
		InterfaceMonitor:         interfaceMonitor,
	}

	// Set DNS server for TUN interface
	var dnsServers []netip.Addr
	dnsAddrIP, _ := netip.ParseAddr(dnsAddr)
	if dnsAddrIP.IsValid() {
		dnsServers = append(dnsServers, dnsAddrIP)
		log.Info("[TUN] IPv4 DNS server: %s", dnsAddr)
	}

	// Enable IPv6 if requested
	if t.useIPv6 {
		tunOptions.Inet6Address = []netip.Prefix{prefix6}
		tunOptions.Inet6RouteAddress = []netip.Prefix{route6}
		// Exclude IPv6 loopback (::1/128)
		loopback6 := netip.MustParsePrefix("::1/128")
		inet6Exclude = append([]netip.Prefix{loopback6}, inet6Exclude...)
		tunOptions.Inet6RouteExcludeAddress = inet6Exclude
		log.Info("[TUN] Excluding IPv6 loopback: ::1/128")

		// Add IPv6 DNS server
		dnsAddrIPv6, _ := netip.ParseAddr(dnsAddr6)
		if dnsAddrIPv6.IsValid() {
			dnsServers = append(dnsServers, dnsAddrIPv6)
			log.Info("[TUN] IPv6 DNS server: %s", dnsAddr6)
		}
	}

	// Set DNS servers (if any)
	if len(dnsServers) > 0 {
		tunOptions.DNSServers = dnsServers
	}
	tunInterface, err := tun.New(tunOptions)
	if err != nil {
		return err
	}
	failedCloser = append(failedCloser, tunInterface)

	// 通知各平台路由模块当前的 AutoRoute 模式，以便 Windows 等平台决定是否需要手动路由
	setTunRouteAutoMode(autoRoute)
	// Linux: 始终添加 fwmark 策略路由规则；Windows/macOS: 按 AutoRoute 状态决定
	if err := SetupTunRouteRules(); err != nil {
		return err
	}

	ctx, cancel := context.WithCancel(context.Background())
	tunStack, err := tun.NewStack(string(stack), tun.StackOptions{
		Context:         ctx,
		Tun:             tunInterface,
		TunOptions:      tunOptions,
		UDPTimeout:      30,
		Handler:         t,
		Logger:          defaultLogger,
		InterfaceFinder: control.NewDefaultInterfaceFinder(),
	})
	if err != nil {
		cancel()
		return err
	}
	failedCloser = append(failedCloser, tunStack)
	err = tunStack.Start()
	if err != nil {
		cancel()
		return err
	}
	t.cancel = cancel
	t.closer = failedCloser
	failedCloser = nil
	t.waiter = &gvisorWaiter{tunStack}
	t.tunName = tunName // Save for cleanup

	// 执行平台特有的启动后操作（如 Windows AutoRoute 关闭时设置 DNS、macOS 配置网络服务 DNS）
	platformPostStart(dnsServers, t.tunName, autoRoute)

	// 将 CN geosite 列表追加到已有的域名白名单末尾（原列表包含服务器域名等）。
	// 不可直接赋值——那会覆盖 Start() 前通过 AddDomainWhitelist 设置的条目。
	if cnWhitelist, err := GetWhitelistCN(); err == nil {
		t.dns.whitelist = append(t.dns.whitelist, cnWhitelist...)
	} else {
		log.Warn("[TUN] GetWhitelistCN failed: %v", err)
	}
	// 注意：不要在此清空 t.whitelist。
	// t.whitelist 是连接层的 IP 白名单（直连保障），必须在整个 TUN 生命周期内保持有效。
	return nil
}

func (t *singTun) Close() error {
	t.mu.Lock()
	if t.cancel != nil {
		t.cancel()
		t.closer.Close()
		t.cancel = nil
		t.closer = nil
		if t.waiter != nil {
			t.waiter.Wait()
			t.waiter = nil
		}
		// 平台特定清理（Windows 非 AutoRoute 时恢复 DNS、macOS 恢复 networksetup DNS 等）
		platformPreClose(t.tunName, t.runningAutoRoute)
		t.tunName = ""
		// Cleanup routing rules
		CleanupTunRouteRules()
		// Cleanup exclude routes on non-Linux platforms
		if err := CleanupExcludeRoutes(); err != nil {
			log.Warn("[TUN] Failed to cleanup exclude routes: %v", err)
		}
		// 清空白名单与排除列表
		t.whitelist = nil
		t.excludeAddrs = nil
	}
	t.mu.Unlock()
	return nil
}

func (t *singTun) AddDomainWhitelist(domain string) {
	t.dns.whitelist = append(t.dns.whitelist, strmatcher.FullMatcher(domain))
	log.Trace("[TUN] Added domain to DNS whitelist: %s", domain)
}

func (t *singTun) AddIPWhitelist(addr netip.Addr) {
	// 规范化地址：net.LookupIP 返回的 IPv4 往往是 16 字节 IPv4-in-IPv6 形式
	// （Is4In6()），而 sing-tun 传入的连接目标是 4 字节纯 IPv4（Is4()）。
	// 两者在 slices.Contains 中不相等，导致白名单失效。统一 Unmap() 后再存储。
	addr = addr.Unmap()
	if !addr.IsValid() {
		return
	}
	t.whitelist = append(t.whitelist, addr)
	log.Info("[TUN] Added IP to whitelist: %s", addr.String())
	// 同时加入路由排除列表：在 Windows/macOS 等无 fwmark 平台上，
	// 需通过 OS 路由规则彻底阻止这些 IP 进入 TUN。
	prefix := netip.PrefixFrom(addr, addr.BitLen())
	t.excludeAddrs = append(t.excludeAddrs, prefix)
	log.Info("[TUN] Added %s to route exclusion list", prefix.String())
}

func (t *singTun) SetFakeIP(enabled bool) {
	t.dns.useFakeIP = enabled
}

func (t *singTun) SetIPv6(enabled bool) {
	t.useIPv6 = enabled
}

func (t *singTun) SetStrictRoute(enabled bool) {
	t.strictRoute = enabled
}

func (t *singTun) SetAutoRoute(enabled bool) {
	t.autoRoute = enabled
}

func (t *singTun) PrepareConnection(network string, source M.Socksaddr, destination M.Socksaddr, routeContext tun.DirectRouteContext, timeout time.Duration) (tun.DirectRouteDestination, error) {
	// v2rayA 不实现直连路由（所有流量经 newConnectionEx/newPacketConnectionEx 处理）
	return nil, nil
}

func (t *singTun) NewConnectionEx(ctx context.Context, conn net.Conn, source M.Socksaddr, destination M.Socksaddr, onClose N.CloseHandlerFunc) {
	metadata := M.Metadata{
		Source:      source,
		Destination: destination,
	}
	log.Trace("[TUN-NEW] New TCP connection: %s -> %s", source, destination)
	err := t.newConnection(ctx, conn, metadata)
	if err != nil {
		N.CloseOnHandshakeFailure(conn, onClose, err)
	}
}

func (t *singTun) newConnection(ctx context.Context, conn net.Conn, metadata M.Metadata) error {
	err := t.dns.NewConnection(ctx, conn, metadata)
	if err == continueHandler {
		var dialer N.Dialer
		var dialType string
		// Use direct connection for whitelisted IPs or reserved address ranges
		if slices.Contains(t.whitelist, metadata.Destination.Addr) || isReservedAddress(metadata.Destination.Addr) {
			dialer = t.dialer
			dialType = "direct"
			log.Trace("[TUN-TCP] %s -> %s: using DIRECT (whitelisted/reserved)", metadata.Source, metadata.Destination)
		} else {
			dialer = t.forward
			dialType = "socks5"
			log.Trace("[TUN-TCP] %s -> %s: using SOCKS5", metadata.Source, metadata.Destination)
		}
		if domain, ok := t.dns.fakeCache.Load(metadata.Destination.Addr); ok {
			metadata.Destination.Addr = netip.Addr{}
			metadata.Destination.Fqdn = domain
		}
		serverConn, err := dialer.DialContext(ctx, N.NetworkTCP, metadata.Destination)
		if err != nil {
			log.Warn("[TUN-TCP] Failed to dial %s via %s: %v", metadata.Destination, dialType, err)
			conn.Close()
			return err
		}
		log.Trace("[TUN-TCP] Connected to %s via %s", metadata.Destination, dialType)
		err = bufio.CopyConn(ctx, conn, serverConn)
		if err != nil {
			log.Warn("[TUN-TCP] Relay failed %s -> %s via %s: %v", metadata.Source, metadata.Destination, dialType, err)
			return err
		}
		log.Trace("[TUN-TCP] Relay closed %s -> %s via %s", metadata.Source, metadata.Destination, dialType)
		return nil
	}
	return err
}

func (t *singTun) NewPacketConnectionEx(ctx context.Context, conn N.PacketConn, source M.Socksaddr, destination M.Socksaddr, onClose N.CloseHandlerFunc) {
	metadata := M.Metadata{
		Source:      source,
		Destination: destination,
	}
	log.Trace("[TUN-NEW] New UDP connection: %s -> %s", source, destination)
	err := t.newPacketConnection(ctx, conn, metadata)
	if err != nil {
		N.CloseOnHandshakeFailure(conn, onClose, err)
	}
}

func (t *singTun) newPacketConnection(ctx context.Context, conn N.PacketConn, metadata M.Metadata) error {
	err := t.dns.NewPacketConnection(ctx, conn, metadata)
	if err == continueHandler {
		var dialer N.Dialer
		// Use direct connection for whitelisted IPs or reserved address ranges
		if slices.Contains(t.whitelist, metadata.Destination.Addr) || isReservedAddress(metadata.Destination.Addr) {
			dialer = t.dialer
			log.Trace("[TUN-UDP] %s -> %s: using DIRECT (whitelisted/reserved)", metadata.Source, metadata.Destination)
		} else {
			dialer = t.forward
			log.Trace("[TUN-UDP] %s -> %s: using SOCKS5", metadata.Source, metadata.Destination)
		}
		if domain, ok := t.dns.fakeCache.Load(metadata.Destination.Addr); ok {
			metadata.Destination.Addr = netip.Addr{}
			metadata.Destination.Fqdn = domain
		}
		serverConn, err := dialer.ListenPacket(ctx, metadata.Destination)
		if err != nil {
			conn.Close()
			return err
		}
		err = bufio.CopyPacketConn(ctx, conn, bufio.NewPacketConn(serverConn))
		if err != nil {
			log.Warn("[TUN-UDP] Relay failed %s -> %s: %v", metadata.Source, metadata.Destination, err)
			return err
		}
		return nil
	}
	return err
}

func (t *singTun) NewError(ctx context.Context, err error) {
}

func GetWhitelistCN() (Matcher, error) {
	datpath, err := asset.GetV2rayLocationAsset("geosite.dat")
	if err != nil {
		return nil, err
	}
	b, err := os.ReadFile(datpath)
	if err != nil {
		return nil, fmt.Errorf("GetWhitelistCn: %w", err)
	}
	var siteList routercommon.GeoSiteList
	err = proto.Unmarshal(b, &siteList)
	if err != nil {
		return nil, fmt.Errorf("GetWhitelistCn: %w", err)
	}
	var matcher Matcher
	for _, e := range siteList.Entry {
		if e.CountryCode == "CN" {
			for _, dm := range e.Domain {
				switch dm.Type {
				case routercommon.Domain_Plain:
					matcher = append(matcher, strmatcher.SubstrMatcher(dm.Value))
				case routercommon.Domain_Regex:
					r, err := strmatcher.Regex.New(dm.Value)
					if err != nil {
						continue
					}
					matcher = append(matcher, r)
				case routercommon.Domain_RootDomain:
					matcher = append(matcher, strmatcher.DomainMatcher(dm.Value))
				case routercommon.Domain_Full:
					matcher = append(matcher, strmatcher.FullMatcher(dm.Value))
				}
			}
			break
		}
	}
	return matcher, nil
}
